{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "62cbc002",
   "metadata": {
    "id": "62cbc002"
   },
   "source": [
    "### Week 2: Exploring Temperature Trends in Death Valley: A Data Visualization Tutorial"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f3592255",
   "metadata": {
    "id": "f3592255"
   },
   "source": [
    "In this tutorial, we'll examine the temperature trends in Death Valley and other city. We'll explore how these trends are important for climate studies and managing local tourism. Throughout this process, we'll also learn how to utilize `Matplotlib`. By analyzing Death Valley's ( and other cities) temperature data, we'll gain practical experience in visualizing complex datasets, enabling us to better understand and communicate the insights we find through our analysis."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3181120d",
   "metadata": {
    "id": "3181120d"
   },
   "source": [
    "**Step 1: Setting Up Your Environment**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "38189d79",
   "metadata": {
    "id": "38189d79"
   },
   "outputs": [],
   "source": [
    "# Importing pandas for data manipulation\n",
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "872893fa",
   "metadata": {
    "id": "872893fa"
   },
   "source": [
    "**Step 2: Loading the Data**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7ee62e5f",
   "metadata": {
    "id": "7ee62e5f"
   },
   "outputs": [],
   "source": [
    "# Loading the dataset from a URL\n",
    "df = pd.read_csv(\"https://raw.githubusercontent.com/Reben80/Data110-32213/e8196b155350595d2c18ddb0ca6c6e1bd9eca344/dataset/tempnormals.csv\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8ddecfbc",
   "metadata": {
    "id": "8ddecfbc"
   },
   "source": [
    "**Step 3: Isolating the Data of Interest ( In a bad way)**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b4b5b84",
   "metadata": {
    "id": "7b4b5b84"
   },
   "outputs": [],
   "source": [
    "# Creating a DataFrame for Death Valley data\n",
    "dv = df[df['location'] == 'Death Valley']\n",
    "dh=df[df['location']=='Houston']\n",
    "dc=df[df['location']=='Chicago']\n",
    "ds=df[df['location']=='San Diego']\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e11122c2",
   "metadata": {
    "id": "e11122c2"
   },
   "source": [
    "**Step 4: Time to Visualize**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "35055afc",
   "metadata": {
    "id": "35055afc"
   },
   "outputs": [],
   "source": [
    "# Importing matplotlib for visualization\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d78e0719",
   "metadata": {
    "id": "d78e0719"
   },
   "source": [
    "**Step 5: Styling Our Graph**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e3e388ca",
   "metadata": {
    "id": "e3e388ca"
   },
   "source": [
    "**Step 6: Comparing with the Average**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d44abd31",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "d44abd31",
    "outputId": "65220d3c-a596-4f62-db54-a88ac9d331e3"
   },
   "outputs": [],
   "source": [
    "# Calculating the average temperature of Death Valley\n",
    "descriptive_data_dv = dv['temperature'].describe()\n",
    "Average_dv = descriptive_data_dv['mean']\n",
    "print(Average_dv)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "E0u0r59CwzLt",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 513
    },
    "id": "E0u0r59CwzLt",
    "outputId": "508155fe-40f7-4fa5-98a9-2948e08c44de"
   },
   "outputs": [],
   "source": [
    "# Plotting the temperature data with the average temperature\n",
    "plt.figure(figsize=(8,5))\n",
    "plt.style.use('ggplot')\n",
    "\n",
    "plt.axhline(y=Average_dv, linestyle='--', color='lightblue',label='Average')\n",
    "plt.plot(dv['day_of_year'], dv['temperature'], label='Death Valley Temperature')\n",
    "plt.xlabel('Day')\n",
    "plt.ylabel('Temperature')\n",
    "plt.title('Trend Temperature in Death Valley',color='orange')\n",
    "plt.grid(True)\n",
    "plt.legend(facecolor='darkgray', framealpha=.8)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ba4c0104",
   "metadata": {},
   "source": [
    "## Task 1: Temperature Trend Visualization\n",
    "\n",
    "### Objective:\n",
    "Create a temperature trend plot for a city from your dataset, different from any previously used examples. Ensure the plot's style and color scheme are distinct from any prior plots.\n",
    "\n",
    "### Instructions:\n",
    "1. **Data Selection:** Pick a new city's temperature data.\n",
    "2. **Visualization:** Plot the city's daily temperatures.\n",
    "   - Change the plot style, line color, and marker style from the original example.\n",
    "   - Label axes as \"Day of Year\" and \"Temperature\".\n",
    "   - Add a title indicating the city's name and \"Temperature Trend\".\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "42b12a03",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Your Code for Task 1 need to be here"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f8a974f1",
   "metadata": {},
   "source": [
    "## Heatmap Visualization with Seaborn in Python\n",
    "\n",
    "Next, we're going to explore how to visualize data with **heatmaps** using Python's Seaborn library. A heatmap is a graphical representation of data where individual values are depicted as colors. It's an excellent tool for spotting patterns and variations across a matrix.\n",
    "\n",
    "In our case, we're analyzing average monthly temperatures for several locations: Chicago, San Diego, Houston, and Death Valley. Here's how we're doing it:\n",
    "\n",
    "### Steps:\n",
    "\n",
    "1. **Prepare Data**: We have a DataFrame named `df` with temperature data, organized by 'location', 'month', and 'temperature'.\n",
    "2. **Set Custom Order**: We define a specific order for the locations, opting for a reversed sequence for a bit of flair.\n",
    "3. **Group and Calculate**: We group the data by 'location' and 'month', then calculate the average temperature for these combinations.\n",
    "4. **Reorder Data**: We reorder our data to match our custom location sequence.\n",
    "5. **Create Heatmap**: With `sns.heatmap`, we visualize the data. We set the plot size, choose a color scheme indicative of temperatures (`YlOrRd`), and add some aesthetic elements like linewidths.\n",
    "\n",
    "The result is a beautiful heatmap that shows us temperature trends by location and month, making complex data easily digestible at a glance.\n",
    "\n",
    "lets do it\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a633edab",
   "metadata": {},
   "outputs": [],
   "source": [
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "plt.figure(figsize=(12,3))\n",
    "\n",
    "# Assuming 'df' is your DataFrame and it's already loaded\n",
    "# Specifying the order of the locations\n",
    "locations_order_reversed = ['Chicago', 'San Diego', 'Houston', 'Death Valley']\n",
    "\n",
    "# Grouping the data by location and month, then calculating the average temperature\n",
    "heatmap_data = df.groupby(['location', 'month'])['temperature'].mean().unstack(level=1)\n",
    "\n",
    "# Reordering the dataframe based on the reversed location order\n",
    "heatmap_data_reversed = heatmap_data.reindex(locations_order_reversed)\n",
    "\n",
    "# Plotting the heatmap\n",
    "\n",
    "sns.heatmap(heatmap_data_reversed, cmap=\"YlOrRd\", linewidths=0.5, annot=False)\n",
    "plt.title('Average Monthly Temperature Normals by Location')\n",
    "plt.xlabel('Month')\n",
    "plt.ylabel('Location')\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7c974ad0",
   "metadata": {},
   "source": [
    "## Task 2: Visualizing a Numerical Matrix with a Heatmap\n",
    "\n",
    "### Objective:\n",
    "Learn how to create a numerical matrix using NumPy and visualize it with a heatmap using Seaborn and Matplotlib. This task will enhance your data manipulation and visualization skills.\n",
    "\n",
    "### Instructions:\n",
    "\n",
    "#### Step 1: Load Necessary Packages\n",
    "    Ensure you have NumPy, Seaborn, and Matplotlib installed. Import these packages at the beginning of your script. If any packages are missing, install them using pip (e.g., `pip install numpy seaborn matplotlib`).\n",
    "\n",
    "   \n",
    "\n",
    "#### Step 2: Create the Numerical Matrix\n",
    "Use NumPy to generate a 5x5 matrix filled with random integers between 1 and 100. Assign this matrix to a variable named `numerical_matrix`.\n",
    "    # Your code for creating the matrix goes here use `np.random.randint`\n",
    "   \n",
    "\n",
    "#### Step 3: Heatmap Visualization\n",
    "    Visualize the matrix you created in Step 2 as a heatmap using Seaborn.\n",
    "\n",
    "    - Make sure to display the numerical values in each cell of the heatmap by setting the `annot` parameter to `True`.\n",
    "    - Use the `viridis` colormap for your heatmap. Feel free to explore and try out different colormaps.\n",
    "    - Title the heatmap as \"Heatmap of a 5x5 Numerical Matrix\".\n",
    "    - Label the x-axis as \"Column Index\" and the y-axis as \"Row Index\".\n",
    "\n",
    "  \n",
    "\n",
    " ### Reflection Questions:\n",
    "    - How does the choice of colormap affect the visualization and interpretation of the data?\n",
    "    - What insights can you gather from the heatmap about the distribution of values in the numerical matrix?\n",
    "\n",
    "  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c25732ca",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Your code for task 2 should be here"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e37d9b23",
   "metadata": {},
   "source": [
    "**Coming back to Step 3: Isolating the Data of Interest ( In a good way)**\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3aeda26e",
   "metadata": {},
   "source": [
    "\n",
    "### Understanding `groupby` with a Simple Example\n",
    "\n",
    "`groupby` is a powerful concept in pandas that allows you to group your data based on certain columns and then perform operations on those groups. Let's illustrate how it works with a simple example.\n",
    "\n",
    "Suppose we have the following dataset of fruits and their quantities:\n",
    "\n",
    "| Fruit  | Quantity |\n",
    "|--------|----------|\n",
    "| Apple  | 10       |\n",
    "| Banana | 5        |\n",
    "| Apple  | 8        |\n",
    "| Banana | 12       |\n",
    "| Cherry | 7        |\n",
    "\n",
    "\n",
    "We want to find the total quantity for each type of fruit. Here's how you can do that using `groupby`:\n",
    "\n",
    "#### Steps:\n",
    "\n",
    "1. **Group by Fruit**: We tell pandas to group the DataFrame by the 'Fruit' column. Each fruit name (Apple, Banana, Cherry) will be a separate group.\n",
    "2. **Sum Quantities**: For each group, we calculate the sum of the 'Quantity' column.\n",
    "\n",
    "#### Code:\n",
    "\n",
    "```python\n",
    "import pandas as pd\n",
    "\n",
    "# Creating the DataFrame\n",
    "data = {'Fruit': ['Apple', 'Banana', 'Apple', 'Banana', 'Cherry'],\n",
    "        'Quantity': [10, 5, 8, 12, 7]}\n",
    "df = pd.DataFrame(data)\n",
    "\n",
    "# Grouping by 'Fruit' and then summing the 'Quantity' for each group\n",
    "grouped_data = df.groupby('Fruit')['Quantity'].sum()\n",
    "\n",
    "# Display the result\n",
    "print(grouped_data)\n",
    "```\n",
    "\n",
    "#### Output:\n",
    "\n",
    "| Fruit  | Total Quantity |\n",
    "|--------|----------------|\n",
    "| Apple  | 18             |\n",
    "| Banana | 17             |\n",
    "| Cherry | 7              |\n",
    "\n",
    "\n",
    "**Explanation**:\n",
    "\n",
    "- `df.groupby('Fruit')` creates a group for each unique value in the 'Fruit' column.\n",
    "- We then select the 'Quantity' column and apply the `.sum()` function. This function is applied to each group separately, summing the quantities of Apples, Bananas, and Cherries independently.\n",
    "- The result is a new Series where the index is the unique fruits and the values are the summed quantities.\n",
    "\n",
    "`groupby` can be used to perform a variety of operations (like sum, mean, max, etc.) on different groups of data efficiently, making it an indispensable tool for data analysis.\n",
    "```\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "91e0d9be",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#Set the size of the plot\n",
    "plt.figure(figsize=(14, 6))\n",
    "\n",
    "# Group data by location\n",
    "grouped = df.groupby('location')\n",
    "\n",
    "# Loop through each location group and plot the temperature against the day of the year\n",
    "for name, group in grouped:\n",
    "    plt.plot(group['day_of_year'], group['temperature'], label=name)\n",
    "\n",
    "# Adding plot title and labels\n",
    "plt.title('Temperature Trends by Location Throughout the Year')\n",
    "plt.xlabel('Day of the Year')\n",
    "plt.ylabel('Temperature')\n",
    "\n",
    "\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
